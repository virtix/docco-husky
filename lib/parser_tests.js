// Generated by CoffeeScript 1.4.0
(function() {
  var assert, docco, dp, exec, languages, parser, path, spawn, util, utils, _ref;

  path = require('path');

  assert = require('assert');

  languages = require('./../lib/languages').languages();

  dp = require('./../lib/docco-plus');

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  util = require('util');

  docco = {};

  parser = {};

  utils = {};

  suite("Spike", function() {
    return test('figure out for N of iterable', function() {});
  });

  suite('Utils Tests', function() {
    test('Build a list of files from languages and several directories', function() {
      var dirs, files;
      dirs = '../test ../lib ../tests ../src';
      files = utils.build_files(dirs, languages);
      return assert.ok(files.length > 10);
    });
    test('Filter excludes ., hidden, and empty files', function() {
      var dirs, file, files, _i, _len, _results;
      dirs = '../test ../lib ../tests ../src';
      files = utils.build_files(dirs, languages);
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        assert.ok(file !== '.');
        _results.push(assert.ok(file !== '.'));
      }
      return _results;
    });
    test('Given a non-exitent file extension, this should throw an exception', function() {
      var ext;
      ext = 'file.ZZZZZ';
      try {
        utils.get_language(ext, languages);
        return console.log('should not get here');
      } catch (e) {

      }
    });
    test('Given a file extension, returns the language type object', function() {
      var lang, p, paths, _i, _len, _results;
      paths = [['/foo/bar.js', 'javascript'], ['/bar/etc/nanoo.py', 'python'], ['gepetto.pp', 'ruby'], ['.ssh/one.r', 'r'], ['two.R', 'r'], ['/home/baz/%20\ouch.bf', 'brainfuck'], ['asd/lkasdASD/lkasd___.clj', 'clojure'], ['asd.c', 'c'], ['____0asdasdJASkjhb.asd/asdas,.,asd/lklasdu.php', 'php'], ['/d/f/g/h/j/k/q/w/e/r/t/y/u/i/o/coffee.coffee', 'coffee-script']];
      _results = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        p = paths[_i];
        lang = utils.get_language(p[0], languages);
        _results.push(assert.equal(lang, p[1]));
      }
      return _results;
    });
    test('Utils class should be alive', function() {
      return assert(utils !== null);
    });
    test('Test file_exists method', function() {
      var p;
      p = path.resolve('../package.json');
      return assert(utils.file_exists(p));
    });
    return test("Ensure that the output destination directory exists; e.g., ./test/fixtures", function() {
      var dir, retval, _callback;
      dir = path.resolve('./fixtures');
      _callback = function() {
        return 'ok';
      };
      retval = utils.ensure_directory(dir, _callback);
      return assert.equal(retval, 'ok');
    });
  });

  suite('Docco-plus Parser Tests', function() {
    return test('Docco-plus should be alive', function() {
      return assert(docco.get_version() === '0.9', docco.get_version());
    });
  });

  suite('Language Tests', function() {
    test('languages() should return an object.', function() {
      return assert(typeof languages === 'object');
    });
    return test('We want to make sure there are at least 10 languages (but there should be many more)', function() {
      return assert(Object.keys(languages).length > 10);
    });
  });

  before(function() {
    docco = new dp.DoccoPlus;
    parser = new dp.Parser;
    return utils = new dp.Utils;
  });

  after(function() {
    docco = {};
    parser = {};
    return utils = {};
  });

}).call(this);
